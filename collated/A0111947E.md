# A0111947E
###### src\command\DeleteBulkTask.java
``` java
 */
public class DeleteBulkTask extends DeleteCommand {
	private ArrayList<Task> tasks;
	
	public DeleteBulkTask(ArrayList<Task> tasks) {
		this.tasks = tasks;
	}

	@Override
	public void execute() {
		// Firstly, delete into the local memory
		 for(Task t: this.tasks) {
			 TaskMemory.getInstance().Remove(t);
		 }
	}

	@Override
	public void undo() {
		if (this.undoable()) {
			//System.out.println(this.tasks.size());
				CreateBulkTask createbulk = new CreateBulkTask(this.tasks);
				createbulk.execute();
		}
	}

}
```
###### src\command\DeleteCommand.java
``` java
 */
public abstract class DeleteCommand implements ICommand {
	public abstract void execute();

	public abstract void undo();

	public boolean undoable() {
		// return true, because CreateCommand is able to undo.
		return true;
	}
}
```
###### src\command\DeleteTask.java
``` java
 */
public class DeleteTask extends DeleteCommand {
	private Task task;
	public DeleteTask(Task task) {
		this.task = task;
	}

	@Override
	public void execute() {
		// Firstly, delete into the local memory
		 TaskMemory.getInstance().Remove(this.task);
		
		// Secondly, delete this task into the storage
		// Call storage API
	}

	@Override
	public void undo() {
		if (this.undoable()) {
			CreateTask create = new CreateTask(this.task);
			create.execute();
		}

	}

}
```
###### src\command\ICommand.java
``` java
 */
public interface ICommand {
	public void execute();

	public void undo();

	public boolean undoable();
}
```
###### src\command\TaskMemory.java
``` java
 *
 */
public class TaskMemory {
	private static TaskMemory _instance;
	private ArrayList<Task> taskList;

	public TaskMemory() {
		// Storage.getInstance().setfileName("silentjarvis.fxml");
		this.taskList = Storage.getInstance().load();
	}

	// Singleton
	public static TaskMemory getInstance() {
		if (_instance == null) {
			_instance = new TaskMemory();
		}
		return _instance;
	}

	public void loadTask(){
		this.taskList = Storage.getInstance().load();
	}
	
	public ArrayList<Task> getNoArchivedList() {
		ArrayList<Task> noArchivedList = new ArrayList<Task>();
		try {
			String a = "Archived";
			for (Task t : this.taskList) {
				if (!t.getTaskType().contains(a)) {

					noArchivedList.add(t);
				}
			}
			Collections.sort(noArchivedList, new DateComparator());
			return noArchivedList;
		} catch (Exception e) {
			return null;
		}

	}

	// Today + Following + Floating
	public ArrayList<Task> getCombinedTaskList() {
		ArrayList<Task> combinedTaskList = new ArrayList<Task>();
		try {
//			int totalSize = getTodayTaskList().size()
//					+ getFollowingDayTask().size() + getFloatingTask().size();
			combinedTaskList.addAll(getTodayTaskList());
			combinedTaskList.addAll(getFollowingDayTask());
			combinedTaskList.addAll(getFloatingTask());
			
			return combinedTaskList;
		} catch (Exception e) {
			return null;
		}
	}
	
	private boolean checkDue(Task t){
		try{
			for(Task dueTask : getDueTask()){
				if(t instanceof DeadlineTask){
					if(dueTask.equals(t)){
						return true;
					}
				}else if (t instanceof EventTask){
					if(dueTask.equals(t)){
						return true;
					}
				}
			}
			return false;
		}catch(Exception e){
			return true;
		}
	}

	public ArrayList<Task> getTodayTaskList() {
		ArrayList<Task> todayList = new ArrayList<Task>();
		try {

			String dateNow = LocalDate.now().toString();
			String timeNow = LocalTime.now().toString();
			for (Task t : this.taskList) {
				if (t instanceof DeadlineTask) {
					if (((DeadlineTask) t).getDeadlineDate().compareTo(
									dateNow) == 0
							&& (!t.getTaskType().contains("Archived") && !t.getTaskType().contains("Completed")) && !checkDue(t)) {
						todayList.add(t);
					}
				} else if (t instanceof EventTask) {
					if ((((EventTask) t).getStartDate()
									.compareTo(dateNow) <= 0 && ((EventTask) t)
							.getEndDate().compareTo(dateNow) >= 0)
							&& (!t.getTaskType().contains("Archived") && !t.getTaskType().contains("Completed"))  && !checkDue(t)) {
						todayList.add(t);
					}
				}
			}

			Collections.sort(todayList, new DateComparator());
			return todayList;
		} catch (Exception ex) {
			return null;
		}
	}

	public ArrayList<Task> getTaskList() {
		Collections.sort(this.taskList, new DateComparator());
		return this.taskList;
	}

	public ArrayList<Task> getFloatingTask() {
		ArrayList<Task> floatingTaskList = new ArrayList<Task>();
		try {
			for (Task floatingTask : this.taskList) {
				if (floatingTask instanceof FloatingTask) {
					if (!floatingTask.getTaskType().contains("Archived") && !floatingTask.getTaskType().contains("Completed")) {
						floatingTaskList.add((FloatingTask) floatingTask);
					}
				}
			}
			Collections.sort(floatingTaskList, new TaskNameComparator());
			return floatingTaskList;
		} catch (Exception e) {
			return null;
		}

	}

	public ArrayList<Task> getFollowingDayTask() {

		ArrayList<Task> followingDayList = new ArrayList<Task>();
		try {
			String followDayDate = LocalDate.now().plusDays(1).toString();
			String dateNow = LocalDate.now().toString();
			String timeNow = LocalTime.now().toString();
			String dateTimeNow = dateNow + " " + timeNow;
			String followingDateTime = followDayDate + " " + timeNow;
			for (Task t : this.taskList) {
				if (t instanceof DeadlineTask) {
//					String dateTime = ((DeadlineTask) t).getDeadlineDate()
//							+ " " + ((DeadlineTask) t).getDeadlineTime();
					if (((DeadlineTask) t).getDeadlineDate().compareTo(dateNow) > 0) {
						if (!t.getTaskType().contains("Archived") && !t.getTaskType().contains("Completed")) {

							followingDayList.add(t);
						}
					}
				} else if (t instanceof EventTask) {
					String endDateTime = ((EventTask) t).getEndDate() + " "
							+ ((EventTask) t).getEndTime();
					// String startDateTime = ((EventTask) t).getStartDate() +
					// " " + ((EventTask) t).getStartTime();
					if (((EventTask) t).getEndDate().compareTo(dateNow) > 0
							&& ((EventTask) t).getEndDate().compareTo(followDayDate) >= 0) {
						if (!t.getTaskType().contains("Archived") && !t.getTaskType().contains("Completed")) {

							followingDayList.add(t);
						}
					}
				}
			}
			Collections.sort(followingDayList, new DateComparator());
			return followingDayList;
		} catch (Exception e) {
			return null;
		}
	}

	private ArrayList<Task> getDueTask() {
		ArrayList<Task> dueTaskList = new ArrayList<Task>();
		try {

			String dateNow = LocalDate.now().toString();
			String timeNow = LocalTime.now().toString();
			String dateTime = dateNow + " " + timeNow;
			for (Task t : this.taskList) {
				if (t instanceof DeadlineTask) {
					String dateTime2 = ((DeadlineTask) t).getDeadlineDate()
							+ " " + ((DeadlineTask) t).getDeadlineTime();
					if (dateTime2.compareTo(dateTime) < 0) {
						if (!t.getTaskType().contains("Archived") && !t.getTaskType().contains("Completed")) {
							dueTaskList.add(t);
						}

					}
				} else if (t instanceof EventTask) {
					String dateTime2 = ((EventTask) t).getEndDate() + " "
							+ ((EventTask) t).getEndTime();
					if (dateTime2.compareTo(dateTime) < 0) {
						if (!t.getTaskType().contains("Archived") && !t.getTaskType().contains("Completed")) {
							dueTaskList.add(t);
						}
					}
				}
			}
			Collections.sort(dueTaskList, new DateComparator());
			return dueTaskList;
		} catch (Exception e) {
			return null;
		}
	}

	public ArrayList<Task> getArchivedList() {
		ArrayList<Task> archivedList = new ArrayList<Task>();
		try {
			for (Task t : this.taskList) {
				if (t.getTaskType().contains("Archived")) {

					archivedList.add(t);
				}
			}

			return archivedList;
		} catch (Exception e) {
			return null;
		}
	}
	
	public ArrayList<Task> getCompletedList(){
		ArrayList<Task> completedList = new ArrayList<Task>();
		try{
			for(Task t : this.taskList){
				if(t.getTaskType().contains("Completed")){
					completedList.add(t);
				}
			}
			return completedList;
		}catch(Exception e){
			return null;
		}
	}

	public void Add(Task task) {
		this.taskList.add(task);
	}

	public void Remove(Task task) {
		if (task instanceof DeadlineTask) {
			this.taskList.remove(task);
		} else if (task instanceof FloatingTask) {
			this.taskList.remove(task);
		} else if (task instanceof EventTask) {
			this.taskList.remove(task);
		}

	}

	public int getSize() {
		return taskList.size();
	}
}
```
###### src\command\TaskNameComparator.java
``` java
 */
public class TaskNameComparator implements Comparator<Task> {

	@Override
	public int compare(Task arg0, Task arg1) {
		return arg0.getTaskName().compareTo(arg1.getTaskName());
	}

}
```
###### src\command\UpdateBulkTask.java
``` java
 */
public class UpdateBulkTask extends UpdateCommand {
	private ArrayList<Task> thisTask;
	private ArrayList<Task> newTask;

	public UpdateBulkTask(ArrayList<Task> thisTask, ArrayList<Task> newTask) {
		this.thisTask = thisTask;
		this.newTask = newTask;
	}

	@Override
	public void execute() {

		for (Task t : this.thisTask){
			TaskMemory.getInstance().Remove(t);
		}
		
		for(Task t : this.newTask){
			TaskMemory.getInstance().Add(t);
		}

	}

	@Override
	public void undo() {
		if (this.undoable()) {
			
			DeleteBulkTask delete = new DeleteBulkTask(this.newTask);
			delete.execute();
			CreateBulkTask create = new CreateBulkTask(this.thisTask);
			create.execute();
			
		}
	}
}
```
###### src\command\UpdateCommand.java
``` java
 */

public abstract class UpdateCommand implements ICommand {
	public abstract void execute();

	public abstract void undo();

	public boolean undoable() {
		// return true, because CreateCommand is able to undo.
		return true;
	}
}
```
###### src\command\UpdateTask.java
``` java
 */
public class UpdateTask extends UpdateCommand {
	private Task thisTask;
	private Task newTask;

	public UpdateTask(Task thisTask, Task newTask) {
		this.thisTask = thisTask;
		this.newTask = newTask;
	}

	@Override
	public void execute() {

		DeleteTask delete = new DeleteTask(this.thisTask);
		delete.execute();

		CreateTask create = new CreateTask(this.newTask);
		create.execute();

	}

	@Override
	public void undo() {
		if (this.undoable()) {
			
			CreateTask create = new CreateTask(this.thisTask);
			create.execute();
			DeleteTask delete = new DeleteTask(this.newTask);
			delete.execute();
		}
	}

}
```
###### src\controller\Controller.java
``` java
 */
public class Controller {
	private static Logic logic = new Logic();
	private static ArrayList<Task> displayList = TaskMemory.getInstance()
			.getCombinedTaskList();
	private static CommandParser parser = null;
	private static String _helpMessage = null;
	private static String _errorMessage = null;

	public static void executeCMD(String input) throws Exception {

		
			parser = new CommandParser(input);

			String _cmdType = parser.getCommandType();
			String _taskName = parser.getTaskName();
			String _startDate = parser.getStartDate();
			String _startTime = parser.getStartTime();
			String _endDate = parser.getEndDate();
			String _endTime = parser.getEndTime();
			String _keyword = parser.getDeleteMode();
			int _taskIndex = parser.getId();
			int[] _listIndex = parser.getDeleteIDs();
			String _searchWord = parser.getSearchWord();
			String _searchByDate = parser.getSearchByDate();
			String _searchOnDate = parser.getSearchOnDate();
			String _editAttr = parser.getEditAttribute();
			String _editInfo = parser.getEditInfo();
			String _showOption = parser.getShowOption();
			String _showByDate = parser.getShowByDate();
			String _showDate = parser.getShowDate();
			String _showEndDate = parser.getShowEndDate();
			String _showStartDate = parser.getShowStartDate();
			String _searchStartDate = parser.getSearchStartDate();
			String _searchEndDate = parser.getSearchEndDate();
			//String _displayMode = parser.getDisplayMode();

			switch (_cmdType.trim()) {
			case "add":
				logic.executeCreateTask(_taskName, _startDate, _startTime,
						_endDate, _endTime);
				displayList = TaskMemory.getInstance().getCombinedTaskList();
				break;
			case "delete":

				if (_keyword != null) {
					logic.deleteAllTask(displayList);
				} else {
					if (_listIndex != null) {
						logic.deleteMultipleTask(displayList, _listIndex);
					} else {
						logic.executeDeleteTask(displayList, _taskIndex);
					}
				}

				displayList = TaskMemory.getInstance().getCombinedTaskList();
				break;

			case "edit":
				int[] index = { _taskIndex };
				if (_editAttr != null && _editInfo != null) {
					logic.executeUpdateTaskByAttribute(displayList, index,
							_editAttr, _editInfo);

				} else {
					logic.executeUpdateTask(displayList, _taskName, _startDate,
							_startTime, _endDate, _endTime, "null", _taskIndex);
				}
				displayList = TaskMemory.getInstance().getNoArchivedList();
				break;

			case "search":
				displayList = getCombinedTaskList();
				if (_searchWord != null) {
					displayList = logic.searchTaskByKeyword(displayList,
							_searchWord.trim());
				} else if (_searchByDate != null) {
					displayList = logic.searchTaskByDate(displayList,
							_searchByDate.trim());
				} else if (_searchOnDate != null) {
					displayList = logic.searchTaskOnDate(displayList,
							_searchOnDate.trim());
				} else if (_searchStartDate != null && _searchEndDate != null) {
					displayList = logic.searchTaskBetweenDate(displayList,
							_searchStartDate, _searchEndDate);
				}

				break;

			case "display":

				//if (_displayMode == null) {
					ArrayList<Task> list = TaskMemory.getInstance().
							getCombinedTaskList();
					displayList = list;
				//}

				break;

			case "undo":
				logic.undo();
				displayList = TaskMemory.getInstance().getCombinedTaskList();
				break;

			case "set":
				String _path = parser.getStoragePath();
				String _filename = parser.getStorageFileName();
				if (_path != null) {
					Storage.getInstance().setPath(_path);
				} else if (_filename != null) {
					Storage.getInstance().setfileName(_filename);
				}
				break;

			case "archive":
				displayList = getCombinedTaskList();
				int[] _archiveIndex = parser.getArchivedIDs();
				_editAttr = "taskType";
				_editInfo = "Archived";
				logic.executeUpdateTaskByAttribute(displayList, _archiveIndex,
						_editAttr, _editInfo);
				displayList = TaskMemory.getInstance().getCombinedTaskList();
				break;

			case "unarchived":
				int[] _unarchiveIndex = parser.getUnarchivedIDs();
				_editAttr = "taskType";
				_editInfo = "null";
				logic.executeUpdateTaskByAttribute(displayList,
						_unarchiveIndex, _editAttr, _editInfo);
				displayList = TaskMemory.getInstance().getCombinedTaskList();
				break;

			case "complete":
				displayList = getCombinedTaskList();
				int[] _completeIndex = parser.getCompleteIDs();
				_editAttr = "taskType";
				_editInfo = "Completed";
				logic.executeUpdateTaskByAttribute(displayList, _completeIndex,
						_editAttr, _editInfo);
				displayList = TaskMemory.getInstance().getCombinedTaskList();
				break;

			case "uncomplete":
				int[] _uncompleteIndex = parser.getUncompleteIDs();
				_editAttr = "taskType";
				_editInfo = "null";
				logic.executeUpdateTaskByAttribute(displayList,
						_uncompleteIndex, _editAttr, _editInfo);
				displayList = TaskMemory.getInstance().getCombinedTaskList();
				break;

			case "show":
				displayList = getCombinedTaskList();
				if (_showByDate != null) {
					displayList = logic.searchTaskByDate(displayList,
							_showByDate);
				} else if (_showDate != null) {
					displayList = logic
							.searchTaskOnDate(displayList, _showDate);
				} else if (_showStartDate != null && _showEndDate != null) {
					displayList = logic.searchTaskBetweenDate(displayList,
							_showStartDate, _showEndDate);
				} else if (_showOption != null) {
					if (_showOption.equalsIgnoreCase("floating")) {
						displayList = TaskMemory.getInstance()
								.getFloatingTask();
					} else if (_showOption.equalsIgnoreCase("archived")) {
						displayList = getArchivedList();
					} else if (_showOption.equalsIgnoreCase("complete")){
						displayList = getCompletedList();
					}
				}
				break;

			case "load":
				TaskMemory.getInstance().loadTask();
				displayList = TaskMemory.getInstance().getCombinedTaskList();

				break;
			case "help":
				String _helpString = parser.getHelpString();
				setHelpMessage(_helpString);
				break;

			case "save":
				logic.save();
				break;
				
			case "clear":
				logic.deleteAllTask(displayList);
				displayList = TaskMemory.getInstance().getCombinedTaskList();
				break;

			case "exit":
				logic.save();
				// close program
				Platform.exit();
				break;
			default:
				throw new Exception(parser.getErrorMessage());

			}
			
	}

	public static ArrayList<Task> getTaskList() {

		return displayList;
	}

	public static int getSize() {
		return displayList.size();
	}
	
	public static String getErrorMessage(){
		return _errorMessage;
	}

	public static String getHelpString() {
		return _helpMessage;
	}
	
	private static void setHelpMessage(String helpMessage){
		_helpMessage = helpMessage;
	}
	
	private static void setErrorMessage(String errorMsg){
		_errorMessage = errorMsg;
	}

	public static ArrayList<Task> getFloatingTaskList() {
		return TaskMemory.getInstance().getFloatingTask();
	}

	public static ArrayList<Task> getFollowingDayTaskList() {
		return TaskMemory.getInstance().getFollowingDayTask();
	}

	public static ArrayList<Task> getArchivedList() {
		return TaskMemory.getInstance().getArchivedList();
	}


	public static ArrayList<Task> getTodayTaskList() {
		return TaskMemory.getInstance().getTodayTaskList();
	}
	
	public static ArrayList<Task> getCombinedTaskList(){
		return TaskMemory.getInstance().getCombinedTaskList();
	}
	
	public static ArrayList<Task> getCompletedList(){
		return TaskMemory.getInstance().getCompletedList();
	}

}
```
###### src\controller\Logic.java
``` java
 *
 */

public class Logic {
	// whoever inherit interface, is able to add in to the stack. It is for Undo
	// purposes
	private static Stack<ICommand> processStack = null;

	public Logic() {
		processStack = new Stack<ICommand>();
	}

	// Public API

	// execute undo
	public void undo() {
		if (processStack.isEmpty()) {

		} else {
			processStack.pop().undo();
		}
	}

	// execute save
	public void save() {
		// Storage.getInstance().setfileName("silentjarvis.fxml");
		Storage.getInstance().save(TaskMemory.getInstance().getTaskList());
	}

	// execute create task
	public void executeCreateTask(String task_name, String start_date,
			String start_time, String end_date, String end_time) {
		try {
			Task task;
			task = buildTask(task_name.trim(), start_date, end_date,
					start_time, end_time, "null");
			CreateTask create = new CreateTask(task);
			create.execute();
			pushToProcessStack(create);
		} catch (Exception e) {

		}
	}

	// execute delete task
	public void executeDeleteTask(ArrayList<Task> displayList, int task_index) {
		Task task;
		task = deleteTask(displayList, task_index);
		DeleteTask delete = new DeleteTask(task);
		delete.execute();
		pushToProcessStack(delete);
	}

	// execute deleting tasks with multiple id
	public void deleteMultipleTask(ArrayList<Task> currentList, int[] _listIndex) {
		ArrayList<Task> deleteBulkArray = new ArrayList<Task>();
		deleteBulkArray = getTaskByMutlipleId(currentList, _listIndex);
		DeleteBulkTask deletebulk = new DeleteBulkTask(deleteBulkArray);
		deletebulk.execute();
		pushToProcessStack(deletebulk);
	}

	// execute deleting all tasks in the current view list
	public void deleteAllTask(ArrayList<Task> currentList) {
		ArrayList<Task> deleteBulkArray = new ArrayList<Task>();
		for (int i = 0; i < currentList.size(); i++) {
			if (deleteBulkArray.isEmpty()) {
				deleteBulkArray.add(currentList.get(i));
			} else {
				if (!deleteBulkArray.contains(currentList.get(i))) {
					deleteBulkArray.add(currentList.get(i));
				}
			}
		}

		DeleteBulkTask deletebulk = new DeleteBulkTask(deleteBulkArray);
		deletebulk.execute();
		pushToProcessStack(deletebulk);
	}

	// search between dates
	public ArrayList<Task> searchTaskBetweenDate(ArrayList<Task> currentList,
			String first_date, String second_date) {
		ArrayList<Task> taskOfSearchedList = new ArrayList<Task>();
		try {
			for (Task t : currentList) {
				if (t.getTaskType() != "Archived") {
					if (t instanceof DeadlineTask) {
						if (((DeadlineTask) t).getDeadlineDate().compareTo(
								first_date) >= 0
								&& ((DeadlineTask) t).getDeadlineDate()
										.compareTo(second_date) <= 0) {
							taskOfSearchedList.add(t);
						}
					} else if (t instanceof EventTask) {
						if (((EventTask) t).getEndDate().compareTo(first_date) >= 0
								&& ((EventTask) t).getEndDate().compareTo(
										second_date) <= 0) {
							taskOfSearchedList.add(t);
						}
					}
				}
			}

		} catch (Exception e) {

		}
		return taskOfSearchedList;
	}

	// Search on date
	public ArrayList<Task> searchTaskOnDate(ArrayList<Task> currentList,
			String end_date) {
		ArrayList<Task> taskOfSearchedList = new ArrayList<Task>();
		try {
			// get all task on the search date.
			for (Task t : currentList) {
				if (t.getTaskType() != "Archived") {
					if (t instanceof DeadlineTask) {
						if (((DeadlineTask) t).getDeadlineDate().compareTo(
								end_date) == 0) {
							taskOfSearchedList.add(t);
						}
					} else if (t instanceof EventTask) {
						if (((EventTask) t).getEndDate().compareTo(end_date) == 0) {
							taskOfSearchedList.add(t);
						}
					}
				}
			}

		} catch (Exception e) {

		}
		return taskOfSearchedList;
	}

	// Search by date
	public ArrayList<Task> searchTaskByDate(ArrayList<Task> currentList,
			String end_date) {
		ArrayList<Task> taskOfSearchedList = new ArrayList<Task>();
		try {
			// get all task by the end date
			// search by tomorrow |search by 2015-10-10
			String dateNow = LocalDate.now().toString();
			for (Task t : currentList) {
				if (t.getTaskType() != "Archived") {
					if (t instanceof DeadlineTask) {
						if (((DeadlineTask) t).getDeadlineDate().compareTo(
								dateNow) >= 0
								&& ((DeadlineTask) t).getDeadlineDate()
										.compareTo(end_date) <= 0) {
							taskOfSearchedList.add(t);
						}
					} else if (t instanceof EventTask) {
						if (((EventTask) t).getEndDate().compareTo(dateNow) >= 0
								&& ((EventTask) t).getEndDate().compareTo(
										end_date) <= 0) {
							taskOfSearchedList.add(t);
						}
					}
				}
			}
		} catch (Exception e) {

		}
		return taskOfSearchedList;
	}

	// Searching for tasks , return the filtered arraylist based on the keyword
	public ArrayList<Task> searchTaskByKeyword(ArrayList<Task> currentList,
			String keyword) {
		ArrayList<Task> taskOfSearchedList = new ArrayList<Task>();
		try {
			ArrayList<Task> taskList = currentList;

			// Tokenize the String with a regular expression in Split.
			String[] tokens = keyword.split("[\\ ]");
			for (String token : tokens) {
				for (Task t : taskList) {
					if (!taskOfSearchedList.contains(t)) {
						if (t.getTaskName() != null
								&& Pattern
										.compile(Pattern.quote(token),
												Pattern.CASE_INSENSITIVE)
										.matcher(t.getTaskName()).find()
								&& t.getTaskType() != "Archived") {
							taskOfSearchedList.add(t);
						}
					}
				}
			}

		} catch (Exception e) {

		}

		return taskOfSearchedList;
	}

	// execute update task
	public void executeUpdateTask(ArrayList<Task> currentList,
			String task_name, String start_date, String start_time,
			String end_date, String end_time, String task_type, int task_index) {
		Task deleteTask = SearchTaskById(currentList, task_index);
		Task updateTask = buildTask(task_name.trim(), start_date, end_date,
				start_time, end_time, task_type);

		UpdateTask update = new UpdateTask(deleteTask, updateTask);
		update.execute();
		pushToProcessStack(update);
	}

	// execute update task by certain attribute
	public void executeUpdateTaskByAttribute(ArrayList<Task> currentList,
			int[] task_index, String editAttr, String editInfo) {
		try {
			ArrayList<Task> oldTask = new ArrayList<Task>();
			ArrayList<Task> newTask = new ArrayList<Task>();

			oldTask = getTaskByMutlipleId(currentList, task_index);

			for (Task task : oldTask) {

				String task_name = null;
				String start_date = null;
				String end_date = null;
				String start_time = null;
				String end_time = null;
				String task_type = null;
				boolean check = checkTaskType(task, editInfo);

				if (task instanceof EventTask) {
					task_name = task.getTaskName();
					start_date = ((EventTask) task).getStartDate();
					end_date = ((EventTask) task).getEndDate();
					start_time = ((EventTask) task).getStartTime();
					end_time = ((EventTask) task).getEndTime();
					task_type = task.getTaskType();

					if (editAttr.equalsIgnoreCase("startDate")) {
						start_date = editInfo;
					} else if (editAttr.equalsIgnoreCase("endDate")) {
						end_date = editInfo;
					} else if (editAttr.equalsIgnoreCase("startTime")) {
						start_time = editInfo;
					} else if (editAttr.equalsIgnoreCase("endTime")) {
						end_time = editInfo;
					} else if (editAttr.equalsIgnoreCase("taskName")) {
						task_name = editInfo;
					} else if (editAttr.equalsIgnoreCase("taskType")
							&& check == true) {
						task_type = editInfo;
					}
				} else if (task instanceof DeadlineTask) {
					task_name = task.getTaskName();
					end_date = ((DeadlineTask) task).getDeadlineDate();
					end_time = ((DeadlineTask) task).getDeadlineTime();
					task_type = task.getTaskType();

					if (editAttr.equalsIgnoreCase("endDate")) {
						end_date = editInfo;
					} else if (editAttr.equalsIgnoreCase("endTime")) {
						end_time = editInfo;
					} else if (editAttr.equalsIgnoreCase("taskName")) {
						task_name = editInfo;
					} else if (editAttr.equalsIgnoreCase("taskType")
							&& check == true) {
						task_type = editInfo;
					}
				} else if (task instanceof FloatingTask) {
					task_name = task.getTaskName();
					task_type = task.getTaskType();

					if (editAttr.equalsIgnoreCase("taskName")) {
						task_name = editInfo;
					} else if (editAttr.equalsIgnoreCase("taskType")
							&& check == true) {
						task_type = editInfo;
					}

				}
				Task t = buildTask(task_name, start_date, end_date, start_time,
						end_time, task_type);
				newTask.add(t);
			}
			UpdateBulkTask update = new UpdateBulkTask(oldTask, newTask);
			update.execute();
			pushToProcessStack(update);

		} catch (Exception e) {

		}
	}

	// Private API

	// Push to stack
	private void pushToProcessStack(ICommand command) {
		if (command.undoable()) {
			processStack.push(command);
		}
	}

	// Building a task
	private Task buildTask(String task_name, String start_date,
			String end_date, String start_time, String end_time,
			String task_type) {
		Task task = null;

		try {
			if (task_name.isEmpty()) {
				return null; // fail to add task.
			} else {

				if (start_date != null && end_date != null
						&& start_time != null && end_time != null) {
					// event task
					task = new EventTask(task_name, start_date, end_date,
							start_time, end_time, task_type);
				} else {
					if (start_date == null && end_date == null
							&& start_time == null && end_time == null) {
						// floating task
						task = new FloatingTask(task_name, task_type);
					} else {
						// deadline task
						task = new DeadlineTask(task_name, end_date, end_time,
								task_type);
					}
				}

			}
		} catch (Exception e) {
			return null;
		}
		return task;
	}

	// Deleting a task
	private Task deleteTask(ArrayList<Task> currentList, int index) {
		Task task = null;
		try {
			ArrayList<Task> taskList = TaskMemory.getInstance().getTaskList();
			task = currentList.get(index - 1);
			for (Task t : taskList) {
				if (task.equals(t)) {
					task = t;
				}
			}
		} catch (Exception e) {
			// System.out.println(DELETETASK_MESSAGE);
			return null;
		}
		return task;
	}

	private boolean checkTaskType(Task task, String input) {
		if (task.getTaskType().contains("Completed") && !input.equals("null")) {
			return false;
		} else if (task.getTaskType().contains("Archived")
				&& !input.equals("null")) {
			return false;
		}
		return true;
	}

	// get tasks by a number of index, return arraylist<task>
	private ArrayList<Task> getTaskByMutlipleId(ArrayList<Task> currentList,
			int[] index) {
		ArrayList<Task> taskOfSearchedList = new ArrayList<Task>();
		try {
			for (int i = 0; i < index.length; i++) {
				if (taskOfSearchedList.isEmpty()) {
					taskOfSearchedList.add(currentList.get(index[i] - 1));
				} else {
					if (!taskOfSearchedList.contains(currentList
							.get(index[i] - 1))) {
						taskOfSearchedList.add(currentList.get(index[i] - 1));
					}
				}
			}

		} catch (Exception e) {

		}
		return taskOfSearchedList;
	}

	// Search for specific task based on the index of the current display list
	// and return the same task from the Task List
	private Task SearchTaskById(ArrayList<Task> currentList, int index) {
		Task results = null;
		try {
			ArrayList<Task> TaskList = TaskMemory.getInstance().getTaskList();
			for (int i = 0; i < TaskList.size(); i++) {
				if (currentList.get(index - 1).equals(TaskList.get(i))) {
					results = TaskList.get(i);
				}
			}
		} catch (Exception e) {

		}
		return results;
	}
}
```
###### src\test\LogicTest.java
``` java
 *
 */
public class LogicTest {
	// get instance from TaskMemory
	ArrayList<Task> taskList = TaskMemory.getInstance().getCombinedTaskList();

	// create logic object
	Logic logic = new Logic();

	@Test
	public void ClearTaskTest() {
		// calling delete all task logic
		logic.deleteAllTask(taskList);
		// call memory instance of combined task list.
		taskList = TaskMemory.getInstance().getCombinedTaskList();

		assertEquals(0, taskList.size());
		logic.save();

	}

	@Test
	public void FailAddTaskTest() {

		ClearTaskTest();
		assertEquals(0, taskList.size());

		// a null task will failed to create
		logic.executeCreateTask(null, null, null, null, null);
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(0, taskList.size());
	}

	@Test
	public void AddEventTaskTest() {
		ClearTaskTest();
		assertEquals(0, taskList.size());

		// create a event task
		logic.executeCreateTask("Event task", "2015-11-05", "2359",
				"2015-11-11", "1000");
		// get instance
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(2, taskList.size());
		// assert event task attribute
		EventTask event = (EventTask) taskList.get(0);
		assertEquals("Event task", event.getTaskName());
		assertEquals("2015-11-05", event.getStartDate());
		assertEquals("2359", event.getStartTime());
		assertEquals("2015-11-11", event.getEndDate());
		assertEquals("1000", event.getEndTime());
		assertEquals("null", event.getTaskType());
	}

	@Test
	public void AddFloatingTaskTest() {
		ClearTaskTest();
		assertEquals(0, taskList.size());
		// create a floating task
		logic.executeCreateTask("Floating task", null, null, null, null);

		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(1, taskList.size());
		assertEquals("Floating task", taskList.get(0).getTaskName());
		assertEquals("null", taskList.get(0).getTaskType());
	}

	@Test
	public void AddDeadlineTaskTest() {
		ClearTaskTest();
		assertEquals(0, taskList.size());

		// create a deadline task
		logic.executeCreateTask("Deadline task", null, null, "2015-11-12",
				"1100");

		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(1, taskList.size());
		DeadlineTask deadline = (DeadlineTask) taskList.get(0);
		assertEquals("Deadline task", deadline.getTaskName());
		assertEquals("2015-11-12", deadline.getDeadlineDate());
		assertEquals("1100", deadline.getDeadlineTime());

	}

	@Test
	public void deleteTaskTest() {
		ClearTaskTest();
		assertEquals(0, taskList.size());

		logic.executeCreateTask("Float", null, null, null, null);
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(1, taskList.size());

		// delete task index 1 which is Floating task
		logic.executeDeleteTask(taskList, 1);
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(0, taskList.size());
	}

	@Test
	public void deleteMultipleTastTest() {
		ClearTaskTest();
		assertEquals(0, taskList.size());

		logic.executeCreateTask("Float", null, null, null, null);
		logic.executeCreateTask("Float2", null, null, null, null);

		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(2, taskList.size());

		// delete multiple task, index 1 and 2, which is Floating task. Float
		// and Float2
		int[] index = { 1, 2 };
		logic.deleteMultipleTask(taskList, index);
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(0, taskList.size());
	}

	@Test
	public void searchByKeyWordTest() {
		ClearTaskTest();
		assertEquals(0, taskList.size());

		logic.executeCreateTask("Float", null, null, null, null);
		logic.executeCreateTask("Float2", null, null, null, null);
		logic.executeCreateTask("Home", null, null, null, null);
		logic.executeCreateTask("MEETING WITH BOSS", null, null, null, null);
		logic.executeCreateTask("BOSS", null, null, null, null);
		logic.executeCreateTask("HELLO", null, null, null, null);

		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(6, taskList.size());

		// search by keyword "BOSS"
		taskList = logic.searchTaskByKeyword(taskList, "BOSS");
		assertEquals(2, taskList.size());
		assertEquals("BOSS", taskList.get(0).getTaskName());
		assertEquals("MEETING WITH BOSS", taskList.get(1).getTaskName());

		taskList = TaskMemory.getInstance().getCombinedTaskList();
		// search by keyword "HoMe" with case sensitive
		taskList = logic.searchTaskByKeyword(taskList, "HoMe");
		assertEquals("Home", taskList.get(0).getTaskName());

		taskList = TaskMemory.getInstance().getCombinedTaskList();
		// search by key with word jumble up
		taskList = logic.searchTaskByKeyword(taskList, "BOSS WITH");
		assertEquals("BOSS", taskList.get(0).getTaskName());
		assertEquals("MEETING WITH BOSS", taskList.get(1).getTaskName());

	}

	@Test
	public void searchByDateTest() {
		ClearTaskTest();
		assertEquals(0, taskList.size());

		logic.executeCreateTask("Event1", "2016-12-01", "0800", "2016-12-12",
				"0800");
		logic.executeCreateTask("Event2", "2015-12-12", "0800", "2015-12-13",
				"0800");
		logic.executeCreateTask("Deadline1", null, null, "2015-12-25", "0800");

		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(3, taskList.size());

		// search task by date, it will give you a list of task with
		// deadline/end date before searched date.
		taskList = logic.searchTaskByDate(taskList, "2015-12-12");
		assertEquals(0, taskList.size());
		taskList = TaskMemory.getInstance().getCombinedTaskList();

		taskList = logic.searchTaskByDate(taskList, "2015-12-13");
		assertEquals(1, taskList.size());
		taskList = TaskMemory.getInstance().getCombinedTaskList();

		taskList = logic.searchTaskByDate(taskList, "2015-12-25");
		assertEquals(2, taskList.size());
		taskList = TaskMemory.getInstance().getCombinedTaskList();

		taskList = logic.searchTaskByDate(taskList, "2016-12-12");
		assertEquals(3, taskList.size());
		taskList = TaskMemory.getInstance().getCombinedTaskList();

	}

	@Test
	public void searchOnDateTest() {
		ClearTaskTest();
		assertEquals(0, taskList.size());

		logic.executeCreateTask("Event1", "2016-12-01", "0800", "2016-12-12",
				"0800");
		logic.executeCreateTask("Event2", "2015-12-12", "0800", "2015-12-13",
				"0800");
		logic.executeCreateTask("Deadline1", null, null, "2015-12-25", "0800");

		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(3, taskList.size());

		// search task on date. it will return a list of task with the specific
		// date given
		taskList = logic.searchTaskOnDate(taskList, "2015-12-12");
		assertEquals(0, taskList.size());
		taskList = TaskMemory.getInstance().getCombinedTaskList();

		taskList = logic.searchTaskOnDate(taskList, "2015-12-13");
		assertEquals(1, taskList.size());
		taskList = TaskMemory.getInstance().getCombinedTaskList();

		taskList = logic.searchTaskOnDate(taskList, "2015-12-25");
		assertEquals(1, taskList.size());
		taskList = TaskMemory.getInstance().getCombinedTaskList();

		taskList = logic.searchTaskOnDate(taskList, "2016-12-12");
		assertEquals(1, taskList.size());
		taskList = TaskMemory.getInstance().getCombinedTaskList();
	}

	@Test
	public void undoTest() {
		ClearTaskTest();
		assertEquals(0, taskList.size());

		logic.executeCreateTask("Event1", "2016-12-01", "0800", "2016-12-12",
				"0800");
		logic.executeCreateTask("Event2", "2015-12-12", "0800", "2015-12-13",
				"0800");
		logic.executeCreateTask("Deadline1", null, null, "2015-12-25", "0800");

		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(3, taskList.size());
		// test for undo
		logic.undo();
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(2, taskList.size());

		logic.undo();
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(1, taskList.size());

		logic.undo();
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(0, taskList.size());

		logic.undo();
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(6, taskList.size());

	}

	@Test
	public void searchBetweenDateTest() {
		ClearTaskTest();
		assertEquals(0, taskList.size());

		logic.executeCreateTask("Event1", "2016-12-01", "0800", "2016-12-12",
				"0800");
		logic.executeCreateTask("Event2", "2015-12-12", "0800", "2015-12-13",
				"0800");
		logic.executeCreateTask("Event3", "2015-12-13", "0800", "2015-12-14",
				"0800");
		logic.executeCreateTask("Event4", "2015-12-14", "0800", "2015-12-15",
				"0800");
		logic.executeCreateTask("Event5", "2015-12-15", "0800", "2015-12-16",
				"0800");
		logic.executeCreateTask("deadline", null, null, "2015-12-12", "0700");
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(6, taskList.size());

		// search tasks between the dates.
		taskList = logic.searchTaskBetweenDate(taskList, "2015-12-12",
				"2015-12-14");
		assertEquals(3, taskList.size());
		taskList = TaskMemory.getInstance().getCombinedTaskList();

		taskList = logic.searchTaskBetweenDate(taskList, "2015-12-12",
				"2015-12-16");
		assertEquals(5, taskList.size());
		taskList = TaskMemory.getInstance().getCombinedTaskList();

		taskList = logic.searchTaskBetweenDate(taskList, "2015-12-12",
				"2016-12-16");
		assertEquals(6, taskList.size());
		taskList = TaskMemory.getInstance().getCombinedTaskList();

	}

	@Test
	public void updateTaskTest() {

		ClearTaskTest();
		assertEquals(0, taskList.size());

		logic.executeCreateTask("Float1", null, null, null, null);
		logic.executeCreateTask("Deadline1", null, null, "2015-12-13", "0800");
		logic.executeCreateTask("Event3", "2015-12-13", "0800", "2015-12-14",
				"0800");
		logic.executeCreateTask("Event4", "2015-12-14", "0800", "2015-12-15",
				"0800");
		logic.executeCreateTask("Event5", "2015-12-15", "0800", "2015-12-16",
				"0800");

		// Update the task bu index
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(5, taskList.size());
		assertEquals("Deadline1", taskList.get(0).getTaskName());
		DeadlineTask deadline = (DeadlineTask) taskList.get(0);
		assertEquals("2015-12-13", deadline.getDeadlineDate());
		assertEquals("0800", deadline.getDeadlineTime());

		logic.executeUpdateTask(taskList, "Deadline2", null, null,
				"2015-12-14", "0700", "null", 1);
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(5, taskList.size());
		assertEquals("Deadline2", taskList.get(0).getTaskName());
		deadline = (DeadlineTask) taskList.get(0);
		assertEquals("2015-12-14", deadline.getDeadlineDate());
		assertEquals("0700", deadline.getDeadlineTime());

		assertEquals("Float1", taskList.get(4).getTaskName());

		logic.executeUpdateTask(taskList, "Home sweet Home", null, null, null,
				null, "null", 5);
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(5, taskList.size());
		assertEquals("Home sweet Home", taskList.get(4).getTaskName());
	}

	@Test
	public void updateTaskByAttrTest() {
		ClearTaskTest();
		assertEquals(0, taskList.size());

		logic.executeCreateTask("Float1", null, null, null, null);
		logic.executeCreateTask("Deadline1", null, null, "2015-12-13", "0800");
		logic.executeCreateTask("Event3", "2015-12-13", "0800", "2015-12-14",
				"0800");
		logic.executeCreateTask("Event4", "2015-12-14", "0800", "2015-12-15",
				"0800");
		logic.executeCreateTask("Event5", "2015-12-15", "0800", "2015-12-16",
				"0800");

		// update the task by index and the attribute
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(5, taskList.size());
		assertEquals("Deadline1", taskList.get(0).getTaskName());
		DeadlineTask deadline = (DeadlineTask) taskList.get(0);
		assertEquals("2015-12-13", deadline.getDeadlineDate());
		assertEquals("0800", deadline.getDeadlineTime());
		assertEquals("null", deadline.getTaskType());

		int[] index = { 1 };
		logic.executeUpdateTaskByAttribute(taskList, index, "taskName",
				"Deadline4");
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(5, taskList.size());
		assertEquals("Deadline4", taskList.get(0).getTaskName());
		deadline = (DeadlineTask) taskList.get(0);
		assertEquals("2015-12-13", deadline.getDeadlineDate());
		assertEquals("0800", deadline.getDeadlineTime());
		assertEquals("null", deadline.getTaskType());

		logic.executeUpdateTaskByAttribute(taskList, index, "endTime", "0700");
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(5, taskList.size());
		assertEquals("Deadline4", taskList.get(0).getTaskName());
		deadline = (DeadlineTask) taskList.get(0);
		assertEquals("2015-12-13", deadline.getDeadlineDate());
		assertEquals("0700", deadline.getDeadlineTime());
		assertEquals("null", deadline.getTaskType());

		logic.executeUpdateTaskByAttribute(taskList, index, "endDate",
				"2015-12-11");
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(5, taskList.size());
		assertEquals("Deadline4", taskList.get(0).getTaskName());
		deadline = (DeadlineTask) taskList.get(0);
		assertEquals("2015-12-11", deadline.getDeadlineDate());
		assertEquals("0700", deadline.getDeadlineTime());
		assertEquals("null", deadline.getTaskType());

		logic.executeUpdateTaskByAttribute(taskList, index, "taskType",
				"Completed");
		logic.undo();
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(5, taskList.size());
		assertEquals("Deadline4", taskList.get(0).getTaskName());
		deadline = (DeadlineTask) taskList.get(0);
		assertEquals("2015-12-11", deadline.getDeadlineDate());
		assertEquals("0700", deadline.getDeadlineTime());
		assertEquals("null", deadline.getTaskType());

		logic.executeUpdateTaskByAttribute(taskList, index, "taskType",
				"Archive");
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(5, taskList.size());
		assertEquals("Deadline4", taskList.get(0).getTaskName());
		deadline = (DeadlineTask) taskList.get(0);
		assertEquals("2015-12-11", deadline.getDeadlineDate());
		assertEquals("0700", deadline.getDeadlineTime());
		assertEquals("Archive", deadline.getTaskType());

		logic.undo();
		int[] index2 = { 2 };

		logic.executeUpdateTaskByAttribute(taskList, index2, "taskname",
				"Event100");
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(5, taskList.size());
		assertEquals("Event100", taskList.get(1).getTaskName());
		EventTask event = (EventTask) taskList.get(1);
		assertEquals("2015-12-13", event.getStartDate());
		assertEquals("0800", event.getStartTime());
		assertEquals("2015-12-14", event.getEndDate());
		assertEquals("0800", event.getEndTime());

		logic.executeUpdateTaskByAttribute(taskList, index2, "startdate",
				"2015-12-11");
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(5, taskList.size());
		assertEquals("Event100", taskList.get(1).getTaskName());
		event = (EventTask) taskList.get(1);
		assertEquals("2015-12-11", event.getStartDate());
		assertEquals("0800", event.getStartTime());
		assertEquals("2015-12-14", event.getEndDate());
		assertEquals("0800", event.getEndTime());

		logic.executeUpdateTaskByAttribute(taskList, index2, "starttime",
				"0900");
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(5, taskList.size());
		assertEquals("Event100", taskList.get(1).getTaskName());
		event = (EventTask) taskList.get(1);
		assertEquals("2015-12-11", event.getStartDate());
		assertEquals("0900", event.getStartTime());
		assertEquals("2015-12-14", event.getEndDate());
		assertEquals("0800", event.getEndTime());

		logic.executeUpdateTaskByAttribute(taskList, index2, "enddate",
				"2015-12-13");
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(5, taskList.size());
		assertEquals("Event100", taskList.get(1).getTaskName());
		event = (EventTask) taskList.get(1);
		assertEquals("2015-12-11", event.getStartDate());
		assertEquals("0900", event.getStartTime());
		assertEquals("2015-12-13", event.getEndDate());
		assertEquals("0800", event.getEndTime());

		logic.executeUpdateTaskByAttribute(taskList, index2, "endtime", "0900");
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(5, taskList.size());
		assertEquals("Event100", taskList.get(1).getTaskName());
		event = (EventTask) taskList.get(1);
		assertEquals("2015-12-11", event.getStartDate());
		assertEquals("0900", event.getStartTime());
		assertEquals("2015-12-13", event.getEndDate());
		assertEquals("0900", event.getEndTime());

		logic.executeUpdateTaskByAttribute(taskList, index2, "taskType",
				"Completed");
		logic.undo();
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(5, taskList.size());
		assertEquals("Event100", taskList.get(1).getTaskName());
		event = (EventTask) taskList.get(1);
		assertEquals("2015-12-11", event.getStartDate());
		assertEquals("0900", event.getStartTime());
		assertEquals("2015-12-13", event.getEndDate());
		assertEquals("0900", event.getEndTime());

		logic.executeUpdateTaskByAttribute(taskList, index2, "taskType",
				"Archived");
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(4, taskList.size());
		assertEquals("Event4", taskList.get(1).getTaskName());
		event = (EventTask) taskList.get(1);
		assertEquals("2015-12-14", event.getStartDate());
		assertEquals("0800", event.getStartTime());
		assertEquals("2015-12-15", event.getEndDate());
		assertEquals("0800", event.getEndTime());
		assertEquals("null", event.getTaskType());

		int[] index3 = { 4 };
		logic.executeUpdateTaskByAttribute(taskList, index3, "taskname",
				"floatthere");
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(4, taskList.size());
		assertEquals("floatthere", taskList.get(3).getTaskName());
		assertEquals("null", taskList.get(3).getTaskType());

		logic.executeUpdateTaskByAttribute(taskList, index3, "tasktype",
				"Completed");
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(3, taskList.size());

		logic.executeUpdateTaskByAttribute(taskList, index3, "taskType",
				"Archived");
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		assertEquals(3, taskList.size());
	}

	@Test
	public void saveTest() {
		ClearTaskTest();
		assertEquals(0, taskList.size());

		logic.executeCreateTask("Float1", null, null, null, null);
		logic.executeCreateTask("Deadline1", null, null, "2015-12-13", "0800");
		logic.executeCreateTask("Event3", "2015-12-13", "0800", "2015-12-14",
				"0800");
		logic.executeCreateTask("Event4", "2015-12-14", "0800", "2015-12-15",
				"0800");
		logic.executeCreateTask("Event5", "2015-12-15", "0800", "2015-12-16",
				"0800");

		logic.save();
	}

	@Test
	public void taskListTest() throws Exception {
		ClearTaskTest();
		assertEquals(0, taskList.size());
		ArrayList<Task> getArchivedList = TaskMemory.getInstance()
				.getArchivedList();
		logic.deleteAllTask(getArchivedList);
		taskList = TaskMemory.getInstance().getCombinedTaskList();
		taskList = TaskMemory.getInstance().getCompletedList();
		logic.deleteAllTask(taskList);
		taskList = TaskMemory.getInstance().getCombinedTaskList();

		taskList = Controller.getFloatingTaskList();
		assertEquals(0, taskList.size());

		Controller.executeCMD("add Float1");
		Controller.executeCMD("add Deadline1 by 2015-12-13 0800");
		Controller
				.executeCMD("add Event3 from 2015-12-13 0800 to 2015-12-14 0800");
		Controller
				.executeCMD("add Event4 from 2015-12-14 0800 to 2015-12-15 0800");
		Controller
				.executeCMD("add Event5 from 2015-12-15 0800 to 2015-12-16 0800");

		taskList = Controller.getFloatingTaskList();
		assertEquals(1, taskList.size());

		taskList = Controller.getFollowingDayTaskList();
		assertEquals(4, taskList.size());

		taskList = Controller.getTodayTaskList();
		assertEquals(0, taskList.size());

		Controller.executeCMD("add deadlin123 by today 2359");
		taskList = Controller.getTodayTaskList();
		assertEquals(1, taskList.size());

		Controller.executeCMD("delete 1");
		taskList = Controller.getCombinedTaskList();
		assertEquals(5, taskList.size());

		Controller.executeCMD("delete 1,2");
		taskList = Controller.getCombinedTaskList();
		assertEquals(3, taskList.size());

		Controller.executeCMD("undo");
		taskList = Controller.getCombinedTaskList();
		assertEquals(5, taskList.size());

		Controller.executeCMD("undo");
		taskList = Controller.getCombinedTaskList();
		assertEquals(6, taskList.size());

		Controller.executeCMD("delete 1-3");
		taskList = Controller.getCombinedTaskList();
		assertEquals(3, taskList.size());

		Controller.executeCMD("delete all");
		taskList = Controller.getCombinedTaskList();
		assertEquals(0, taskList.size());

		Controller.executeCMD("undo");
		taskList = Controller.getCombinedTaskList();
		assertEquals(3, taskList.size());

		assertEquals("Float1", taskList.get(2).getTaskName());
		Controller.executeCMD("edit 3 taskName helloWord");
		taskList = Controller.getCombinedTaskList();
		assertEquals(3, taskList.size());
		assertEquals("helloWord", taskList.get(2).getTaskName());

		Controller.executeCMD("edit 3 hello123");
		taskList = Controller.getCombinedTaskList();
		assertEquals(3, taskList.size());
		assertEquals("hello123", taskList.get(2).getTaskName());
		Controller.executeCMD("undo");
		taskList = Controller.getCombinedTaskList();
		assertEquals(3, taskList.size());
		assertEquals("helloWord", taskList.get(2).getTaskName());
		Controller.executeCMD("edit 3 hello123");
		taskList = Controller.getCombinedTaskList();
		assertEquals(3, taskList.size());
		assertEquals("hello123", taskList.get(2).getTaskName());

		Controller.executeCMD("search hello123");
		taskList = Controller.getTaskList();
		assertEquals(1, taskList.size());

		Controller.executeCMD("display");
		taskList = Controller.getTaskList();
		assertEquals(3, taskList.size());

		Controller.executeCMD("search by 2015-12-14");
		taskList = Controller.getTaskList();
		assertEquals(0, taskList.size());

		Controller.executeCMD("display");
		taskList = Controller.getTaskList();
		assertEquals(3, taskList.size());

		Controller.executeCMD("search by 2015-12-16");
		taskList = Controller.getTaskList();
		int size = Controller.getSize();
		assertEquals(2, size);

		Controller.executeCMD("display");
		taskList = Controller.getTaskList();

		Controller.executeCMD("search on 2015-12-16");
		taskList = Controller.getTaskList();
		assertEquals(1, taskList.size());

		Controller.executeCMD("display");
		taskList = Controller.getTaskList();
		Controller.executeCMD("search from today to 2015-12-16");
		taskList = Controller.getTaskList();
		assertEquals(2, taskList.size());

		Controller.executeCMD("display");
		Controller.executeCMD("set path testing");
		String path = "testing" + "\\";
		assertEquals(path, Storage.getInstance().getPath());

		Controller.executeCMD("set filename newfile");
		String filename = "newfile.fxml";
		assertEquals(filename, Storage.getInstance().getfileName());

		Controller.executeCMD("archive 1");
		taskList = Controller.getCombinedTaskList();
		assertEquals(2, taskList.size());

		Controller.executeCMD("display");
		Controller.executeCMD("undo");
		Controller.executeCMD("archive 1-2");
		taskList = Controller.getCombinedTaskList();
		assertEquals(1, taskList.size());

		Controller.executeCMD("display");
		Controller.executeCMD("show archived");
		taskList = Controller.getArchivedList();
		assertEquals(2, taskList.size());

		Controller.executeCMD("unarchived 1,2");
		taskList = Controller.getCombinedTaskList();
		assertEquals(3, taskList.size());

		Controller.executeCMD("complete 1-3");
		taskList = Controller.getTaskList();
		assertEquals(0, taskList.size());

		Controller.executeCMD("show complete");
		taskList = Controller.getCompletedList();
		assertEquals(3, taskList.size());

		Controller.executeCMD("uncomplete 1-2");
		taskList = Controller.getTaskList();
		assertEquals(2, taskList.size());

		Controller.executeCMD("show by 2015-12-16");
		taskList = Controller.getCombinedTaskList();
		assertEquals(2, taskList.size());
		Controller.executeCMD("display");
		Controller.executeCMD("show on 2015-12-16");
		taskList = Controller.getCombinedTaskList();
		assertEquals(2, taskList.size());
		Controller.executeCMD("display");
		Controller.executeCMD("show from today to 2015-12-16");
		taskList = Controller.getCombinedTaskList();
		assertEquals(2, taskList.size());

		Controller.executeCMD("display");
		Controller.executeCMD("show floating");
		taskList = Controller.getFloatingTaskList();
		assertEquals(0, taskList.size());

		Controller.executeCMD("display");
		Controller.executeCMD("save");
		Controller.executeCMD("load");
		taskList = Controller.getCombinedTaskList();
		assertEquals(2, taskList.size());

		Controller.executeCMD("help");
		String help = "add <name>\nadd <name> from <time> to <time>\nadd <name> by   <deadline>\ndelete  <id>\nsearch  <id>\narchive <id>\nedit <id> <attribute> <info>\nset  path     <storage path>\nset  filename <filename>\nshow on <date>\nshow by <date>\nundo\n";
		assertEquals(help, Controller.getHelpString());

		Controller.executeCMD("clear");
		taskList = Controller.getCombinedTaskList();
		assertEquals(0, taskList.size());

		Controller.executeCMD("add abc by today");
		taskList = Controller.getCombinedTaskList();
		assertEquals(0, taskList.size());

		Controller.executeCMD("add eve from today 2359 to today 2359");
		taskList = Controller.getCombinedTaskList();
		assertEquals(1, taskList.size());

		assertEquals(3, TaskMemory.getInstance().getSize());

		Controller.executeCMD("exit");

	}

	@Test
	public void equalsTest() {
		Task a = new FloatingTask("a", null);
		Task b = new FloatingTask("a", null);
		Task c = a;
		assertEquals(true, a.equals(c));
		Task d = new DeadlineTask("abc", "2015-12-12", "0800", "null");
		Task e = new DeadlineTask("abc", "2015-12-12", "0800", "null");
		assertEquals(false, d.equals(e));
		Task f = new EventTask("event", "2015-12-12", "0800", "2015-12-14",
				"0800", "null");
		Task g = new EventTask("event", "2015-12-12", "0800", "2015-12-14",
				"0800", "null");
		Task h = g;
		assertEquals(false, f.equals(g));
		assertEquals(false, a.equals(g));
		assertEquals(false, e.equals(g));
		assertEquals(false, g.equals(a));
		assertEquals(true, h.equals(g));
	}
}
```
